package socketed.common.config;

import net.minecraft.item.Item;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.common.config.Config;
import net.minecraftforge.fml.common.registry.ForgeRegistries;
import socketed.Socketed;

import java.util.HashMap;
import java.util.Map;

public class AddSocketsConfig {
	
	public static final Map<String, Integer> forcedItemTypeRolls = new HashMap<>();
	
	@Config.Comment(
			"Default amount of rolls for item types defined in Socketable Items config" + "\n" +
			"Format: <TYPENAME>,<Rolls>")
	@Config.Name("Socketable Item Type Rolls")
	public String[] socketRollsConfig = {
			"HELMET, 5",
			"CHESTPLATE, 5",
			"LEGGINGS, 5",
			"BOOTS, 5",
			"SWORD, 5",
			"BOW, 1",
			"AXE, 3",
			"PICKAXE, 1",
			"SHOVEL, 1",
			"SHIELD, 5"
	};
	
	@Config.Comment("Base chance when rolling sockets")
	@Config.Name("Socket Rolls Base Chance")
	public float socketRollBaseChance = 0.2F;
	
	@Config.Comment(
			"Minecraft uses Material Enchantability to determine EnchantabilityTier to roll enchantments" + "\n" +
			"EnchantabilityTier (0-7) = MaterialEnchantability / 4" + "\n" +
			"Socket roll chance = Base Chance + EnchantabilityTier * Tier Chance Multiplier")
	@Config.Name("Socket Rolls Tier Chance Multiplier")
	public float socketRollChancePerEnchantabilityTier = 0.08F;
	
	@Config.Comment(
			"Define items here to override the roll chance calculation determined by material enchantability" + "\n" +
			"Format: <MODID:ItemID>,<RollChance>")
	@Config.Name("Socket Rolls Chance Overrides")
	public String[] socketRollChanceByItemId = {
			"iceandfire:armor_silver_metal_helmet, 0.2",
			"iceandfire:armor_silver_metal_chestplate, 0.2",
			"iceandfire:armor_silver_metal_leggings, 0.2",
			"iceandfire:armor_silver_metal_boots, 0.2"
	};

	@Config.Comment("How often an item sold by villagers will attempt to roll with sockets")
	@Config.Name("Merchant Socket Chance")
	public float chanceOnMerchant = 0.2F;

	@Config.Comment("How often an item generated by general loot pools (excluding pre-defined socketed items) will attempt to roll with sockets")
	@Config.Name("General Loot Socket Chance")
	public float chanceOnLootGen = 0.2F;

	@Config.Comment("How often an item generated by mob loot pools will attempt to roll with sockets")
	@Config.Name("Mob Loot Socket Chance")
	public float chanceOnMobDrop = 0.2F;

	@Config.Comment("How many sockets an item sold by villagers can roll at maximum")
	@Config.Name("Merchant Max Sockets")
	public int maxSocketsOnMerchant = 2;

	@Config.Comment("How many sockets an item generated by general loot pools (excluding pre-defined socketed items) can roll at maximum")
	@Config.Name("General Loot Max Sockets")
	public int maxSocketsOnLootGen = 4;

	@Config.Comment("How many sockets an item generated by mob loot pools can roll at maximum")
	@Config.Name("Mob Loot Max Sockets")
	public int maxSocketsOnMobDrop = 6;

	@Config.Comment("Weighted chance for each tier of sockets to be picked when rolling on items (0, 1, 2, 3)")
	@Config.Name("Socket Tier Weights")
	public int[] socketTierWeights = {3, 5, 2, 1};
	
	@Config.Comment("Registers Socket items and recipes to allow adding sockets to existing items")
	@Config.Name("Register Socket Items")
	public boolean registerSocketItems = true;

	private Map<String, Integer> socketRollCountByItemType = null;
	private Map<Item, Float> socketRollChanceByItem = null;
	
	public int getSocketRollCount(String itemTypeString) {
		if(itemTypeString == null) return 0;
		if(this.socketRollCountByItemType == null) this.socketRollCountByItemType = parseRollCounts();
		return this.socketRollCountByItemType.getOrDefault(itemTypeString, 0);
	}

	public float getSocketRollChance(Item item) {
		if(item == null) return -1.0F;
		if(this.socketRollChanceByItem == null) this.socketRollChanceByItem = parseRollChances();
		return this.socketRollChanceByItem.getOrDefault(item, -1.0F);
	}
	
	private HashMap<String, Integer> parseRollCounts() {
		HashMap<String, Integer> map = new HashMap<>();
		for(String s : this.socketRollsConfig) {
			String[] split = s.split(",");
			try {
				if(split.length == 2) {
					map.put(split[0].trim(), Integer.parseInt(split[1].trim()));
				}
				else Socketed.LOGGER.warn("Socket roll count config doesn't have correct format {}", s);
			}
			catch(NumberFormatException exception) {
				Socketed.LOGGER.warn("Socket roll count config can't parse roll count {}", s);
			}
		}
		if(ForgeConfig.SOCKETABLES.allowForcedItemTypes) map.putAll(AddSocketsConfig.forcedItemTypeRolls);
		return map;
	}
	
	private HashMap<Item, Float> parseRollChances() {
		HashMap<Item, Float> map = new HashMap<>();
		for(String s : this.socketRollChanceByItemId) {
			String[] split = s.split(",");
			try {
				if(split.length == 2) {
					ResourceLocation loc = new ResourceLocation(split[0].trim());
					Item item = ForgeRegistries.ITEMS.getValue(loc);
					if(item == null) {
						Socketed.LOGGER.warn("Socket roll chance config doesn't have valid item {}", s);
						continue;
					}
					map.put(item, Float.parseFloat(split[1].trim()));
				}
				else Socketed.LOGGER.warn("Socket roll chance config doesn't have correct format {}", s);
			}
			catch(NumberFormatException exception) {
				Socketed.LOGGER.warn("Socket roll chance config can't parse roll chance {}", s);
			}
		}
		return map;
	}
	
	protected void reset() {
		this.socketRollCountByItemType = null;
		this.socketRollChanceByItem = null;
	}
}